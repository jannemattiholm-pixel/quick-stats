<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quick Statistics — Enter Numbers</title>

  <!-- Chart.js (histogram + density) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b0f17; --card:#121a28; --text:#e8eefc; --muted:#a9b6d3; --line:#23304a;
      --btn:#1f6feb; --ok:#2ea043;
    }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text); }
    .wrap{ max-width:1200px; margin:0 auto; padding:18px; }
    h1{ font-size:22px; margin:6px 0 10px; }
    .sub{ color:var(--muted); margin:0 0 16px; }
    .grid2{ display:grid; grid-template-columns:1.1fr 0.9fr; gap:14px; }
    .grid3{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:14px; }
    @media (max-width:980px){ .grid2{ grid-template-columns:1fr; } .grid3{ grid-template-columns:1fr; } }

    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:14px; box-shadow:0 8px 20px rgba(0,0,0,.25); }
    textarea{
      width:100%; min-height:160px; resize:vertical; background:#0e1524; border:1px solid var(--line);
      color:var(--text); border-radius:12px; padding:12px; font-size:14px; line-height:1.35; outline:none;
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; align-items:center; }
    button{ border:1px solid var(--line); background:#0e1524; color:var(--text); padding:10px 12px; border-radius:12px; cursor:pointer; }
    button.primary{ background:var(--btn); border-color:transparent; }
    button.success{ background:var(--ok); border-color:transparent; }
    button:hover{ filter:brightness(1.08); }
    .meta{ margin-top:10px; color:var(--muted); font-size:13px; }
    .small{ font-size:13px; color:var(--muted); }
    .titleRow{ display:flex; align-items:baseline; justify-content:space-between; gap:10px; }
    .toast{ margin-left:auto; color:var(--muted); font-size:13px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .stats{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px; }
    @media (max-width:520px){ .stats{ grid-template-columns:1fr; } }
    .kv{ border:1px solid var(--line); border-radius:12px; padding:10px; background:#0e1524; }
    .kv .k{ color:var(--muted); font-size:12px; }
    .kv .v{ font-size:16px; margin-top:2px; }

    .note{ margin-top:12px; padding:10px 12px; border-radius:12px; border:1px solid var(--line); background:#0e1524; color:var(--text); }
    .note .title{ font-weight:650; margin-bottom:6px; }

    /* Boxplot canvas gets a bit of padding */
    #boxCanvas{ width:100%; height:190px; display:block; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Enter numbers → histogram + density + Tukey boxplot</h1>
    <p class="sub">
      Paste numbers below (separators: comma, semicolon, whitespace, or newline). All computations run locally in your browser.
    </p>

    <div class="grid2">
      <div class="card">
        <label for="data"><strong>Data</strong></label>
        <textarea id="data" placeholder="Example: 1, 2, 2, 3, 3, 4, 100"></textarea>

        <div class="row">
          <button class="primary" id="analyze">Analyze</button>
          <button id="example">Load example</button>
          <button id="clear">Clear</button>
          <button class="success" id="copyReport" disabled>Copy report</button>
          <span class="toast" id="toast">—</span>
        </div>

        <div class="meta" id="parseInfo">—</div>
      </div>

      <div class="card">
        <div class="titleRow">
          <strong>Histogram</strong>
          <span class="small">Binning: Freedman–Diaconis (Tukey IQR; fallback: √n)</span>
        </div>
        <canvas id="hist" height="190"></canvas>
      </div>
    </div>

    <div style="height:14px"></div>

    <div class="grid3">
      <div class="card">
        <div class="titleRow">
          <strong>Density</strong>
          <span class="small">KDE (Silverman bandwidth)</span>
        </div>
        <canvas id="density" height="190"></canvas>
      </div>

      <div class="card">
        <div class="titleRow">
          <strong>Tukey boxplot</strong>
          <span class="small">outliers shown as points (consistent quartiles)</span>
        </div>
        <canvas id="boxCanvas" width="800" height="190"></canvas>
      </div>

      <div class="card">
        <strong>Summary statistics</strong>
        <div class="stats" id="stats"></div>
        <div class="note" id="interpretation" style="display:none;"></div>
        <div class="small" style="margin-top:10px;">
          Tip: add a single extreme value and compare how the <em>mean</em> changes while the <em>median</em> remains stable.
        </div>
      </div>
    </div>

    <p class="small" style="margin-top:14px;">
      This is a single-file static page (no backend required). It can be hosted for free on GitHub Pages / Cloudflare Pages / Netlify.
    </p>
  </div>

<script>
  // -------------------- Formatting --------------------
  const fmt = (x) => {
    if (!Number.isFinite(x)) return '—';
    const ax = Math.abs(x);
    const s = (ax >= 1000 ? x.toFixed(2) : x.toFixed(4));
    return s.replace(/\.?0+$/,'');
  };

  // -------------------- Parsing --------------------
  function parseNumbers(raw) {
    // separators: comma, semicolon, whitespace, newline
    const cleaned = raw
      .replace(/[，]/g, ',')
      .replace(/[;]/g, ',')
      .replace(/\s+/g, ' ')
      .trim();

    if (!cleaned) return { nums: [], bad: 0 };

    const tokens = cleaned.split(/[,\s]+/).filter(Boolean);
    let bad = 0;
    const nums = [];
    for (const t of tokens) {
      const n = Number(t.replace(',', '.'));
      if (Number.isFinite(n)) nums.push(n);
      else bad++;
    }
    return { nums, bad };
  }

  // -------------------- Core stats --------------------
  function mean(a){ return a.reduce((s,x)=>s+x,0)/a.length; }

  function median(sorted){
    const n = sorted.length;
    const mid = Math.floor(n/2);
    return n % 2 ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;
  }

  // Tukey-style quartiles ("median of halves"):
  // - if n even: lower = first n/2, upper = last n/2
  // - if n odd: exclude median, split remaining into halves
  function tukeyQuartiles(sorted){
    const n = sorted.length;
    if (n === 0) return { q1: NaN, q3: NaN };
    const lower = sorted.slice(0, Math.floor(n/2));
    const upper = sorted.slice(Math.ceil(n/2));
    return { q1: median(lower), q3: median(upper) };
  }

  function sampleStd(a){
    const n = a.length;
    if (n < 2) return NaN;
    const m = mean(a);
    let s2 = 0;
    for (const x of a) s2 += (x-m)*(x-m);
    return Math.sqrt(s2/(n-1));
  }

  function freedmanDiaconisBins(sorted){
    const n = sorted.length;
    if (n < 2) return { bins: 1 };
    const { q1, q3 } = tukeyQuartiles(sorted);
    const iqr = q3 - q1;
    const range = sorted[n-1] - sorted[0];
    if (!(iqr > 0) || !(range > 0)) return { bins: Math.ceil(Math.sqrt(n)) };
    const h = 2 * iqr * Math.pow(n, -1/3);
    const bins = Math.max(1, Math.ceil(range / h));
    return { bins };
  }

  function histogram(sorted, bins){
    const n = sorted.length;
    const min = sorted[0], max = sorted[n-1];
    if (min === max) return { labels:[`${fmt(min)}`], counts:[n] };

    const width = (max - min) / bins;
    const counts = new Array(bins).fill(0);

    for (const x of sorted) {
      const idx = Math.min(bins-1, Math.floor((x - min) / width));
      counts[idx]++;
    }

    const labels = [];
    for (let i=0;i<bins;i++){
      const a = min + i*width;
      const b = a + width;
      labels.push(`${fmt(a)}–${fmt(b)}`);
    }
    return { labels, counts };
  }

  function skewSummary(sorted){
    const m = mean(sorted);
    const med = median(sorted);
    const min = sorted[0], max = sorted[sorted.length-1];
    const left = med - min;
    const right = max - med;
    const delta = m - med;
    const tailRatio = right / (left === 0 ? 1e-9 : left);

    if (Math.abs(delta) < 1e-12 && Math.abs(tailRatio - 1) < 0.15) {
      return { label:'approximately symmetric', short:'approximately symmetric', code:'sym' };
    }
    if (delta > 0 && tailRatio > 1.2) return { label:'right-skewed', short:'right-skewed', code:'right' };
    if (delta < 0 && tailRatio < 0.8) return { label:'left-skewed', short:'left-skewed', code:'left' };
    if (delta > 0) return { label:'likely right-skewed', short:'likely right-skewed', code:'right' };
    if (delta < 0) return { label:'likely left-skewed', short:'likely left-skewed', code:'left' };
    return { label:'no clear skewness pattern', short:'no clear skewness pattern', code:'unclear' };
  }

  // -------------------- KDE (density curve) --------------------
  function kdeGaussian(x, xi, h) {
    const z = (x - xi) / h;
    return Math.exp(-0.5 * z * z) / Math.sqrt(2 * Math.PI);
  }

  function densityKDE(sorted) {
    const n = sorted.length;
    const min = sorted[0], max = sorted[n - 1];
    if (min === max) return { xs: [min], ys: [1] };

    const sd = sampleStd(sorted);
    let h = (Number.isFinite(sd) && sd > 0) ? 1.06 * sd * Math.pow(n, -1/5) : (max - min) / 10;
    if (!Number.isFinite(h) || h <= 0) h = (max - min) / 10;

    const steps = 140;
    const xs = [];
    const ys = [];

    for (let i = 0; i <= steps; i++) {
      const x = min + (max - min) * (i / steps);
      let s = 0;
      for (const xi of sorted) s += kdeGaussian(x, xi, h);
      const y = s / (n * h);
      xs.push(x);
      ys.push(y);
    }
    return { xs, ys };
  }

  // -------------------- Boxplot drawing (consistent quartiles) --------------------
  function drawBoxplot(canvas, summary){
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;

    // Clear
    ctx.clearRect(0,0,w,h);

    // Panel styling (simple, neutral)
    // We do not set specific colors; use current theme via semi-transparent strokes.
    // However canvas requires explicit colors. We'll use subtle default-compatible ones.
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0)'; // transparent
    ctx.fillRect(0,0,w,h);

    const padX = 40;
    const midY = Math.round(h * 0.5);

    const { min, max, q1, q3, medianVal, lo, hi, outliers } = summary;

    if (!Number.isFinite(min) || !Number.isFinite(max) || min === max){
      // Draw a single point label
      ctx.fillStyle = 'rgba(232,238,252,0.85)';
      ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
      ctx.fillText('Not enough variation to draw a boxplot.', 14, 22);
      ctx.restore();
      return;
    }

    const scaleMin = min;
    const scaleMax = max;

    const xMap = (v) => {
      const t = (v - scaleMin) / (scaleMax - scaleMin);
      return padX + t * (w - 2*padX);
    };

    // Whiskers: Tukey fences clipped to data (common practice)
    const whiskerLow = Math.max(min, lo);
    const whiskerHigh = Math.min(max, hi);

    const xMin = xMap(min);
    const xMax = xMap(max);
    const xWL = xMap(whiskerLow);
    const xWH = xMap(whiskerHigh);
    const xQ1 = xMap(q1);
    const xQ3 = xMap(q3);
    const xMed = xMap(medianVal);

    // Draw axis ticks (min, q1, median, q3, max) lightly
    ctx.strokeStyle = 'rgba(169,182,211,0.25)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padX, midY);
    ctx.lineTo(w - padX, midY);
    ctx.stroke();

    // Box
    const boxH = 52;
    ctx.fillStyle = 'rgba(31,111,235,0.20)';
    ctx.strokeStyle = 'rgba(31,111,235,0.85)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(xQ1, midY - boxH/2, (xQ3 - xQ1), boxH);
    ctx.fill();
    ctx.stroke();

    // Median line
    ctx.strokeStyle = 'rgba(232,238,252,0.9)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xMed, midY - boxH/2);
    ctx.lineTo(xMed, midY + boxH/2);
    ctx.stroke();

    // Whiskers
    ctx.strokeStyle = 'rgba(169,182,211,0.85)';
    ctx.lineWidth = 2;

    // Left whisker line from box to whisker low
    ctx.beginPath();
    ctx.moveTo(xQ1, midY);
    ctx.lineTo(xWL, midY);
    ctx.stroke();

    // Right whisker line from box to whisker high
    ctx.beginPath();
    ctx.moveTo(xQ3, midY);
    ctx.lineTo(xWH, midY);
    ctx.stroke();

    // Whisker caps
    const capH = 22;
    ctx.beginPath();
    ctx.moveTo(xWL, midY - capH/2);
    ctx.lineTo(xWL, midY + capH/2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(xWH, midY - capH/2);
    ctx.lineTo(xWH, midY + capH/2);
    ctx.stroke();

    // Outliers as points
    ctx.fillStyle = 'rgba(232,238,252,0.85)';
    for (const v of outliers){
      const x = xMap(v);
      ctx.beginPath();
      ctx.arc(x, midY, 4, 0, Math.PI*2);
      ctx.fill();
    }

    // Labels (min/max)
    ctx.fillStyle = 'rgba(169,182,211,0.85)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.fillText(`min ${fmt(min)}`, Math.max(6, xMin - 24), midY + 74);
    ctx.fillText(`max ${fmt(max)}`, Math.min(w - 90, xMax - 24), midY + 74);

    ctx.restore();
  }

  // -------------------- UI + Charts --------------------
  const elData = document.getElementById('data');
  const elParseInfo = document.getElementById('parseInfo');
  const elStats = document.getElementById('stats');
  const elInterp = document.getElementById('interpretation');
  const elToast = document.getElementById('toast');
  const btnCopy = document.getElementById('copyReport');

  let chartHist, chartDensity;
  let lastReportText = '';
  let lastHasData = false;

  function statCard(k, v){
    const div = document.createElement('div');
    div.className = 'kv';
    div.innerHTML = `<div class="k">${k}</div><div class="v">${v}</div>`;
    return div;
  }

  function setToast(msg){ elToast.textContent = msg; }

  function buildReportText(summary){
    const { n, min, max, meanVal, medianVal, sd, q1, q3, iqr, lo, hi, outliersCount, skew } = summary;
    const sdPart = Number.isFinite(sd) ? ` (SD = ${fmt(sd)})` : '';
    const outPart = (outliersCount > 0)
      ? ` Outliers were detected using Tukey’s rule (values < ${fmt(lo)} or > ${fmt(hi)}; count = ${outliersCount}).`
      : ` No outliers were detected using Tukey’s rule (fences: < ${fmt(lo)} or > ${fmt(hi)}).`;

    return (
      `Dataset summary (n = ${n}). The distribution is ${skew.short}. ` +
      `Median = ${fmt(medianVal)} (IQR = ${fmt(iqr)}; Q1 = ${fmt(q1)}, Q3 = ${fmt(q3)}). ` +
      `Mean = ${fmt(meanVal)}${sdPart}. Range: min = ${fmt(min)}, max = ${fmt(max)}.` +
      outPart
    );
  }

  function render(nums, bad){
    if (nums.length === 0){
      elParseInfo.textContent = 'Enter at least one numeric value.';
      elStats.innerHTML = '';
      elInterp.style.display = 'none';
      if (chartHist) chartHist.destroy();
      if (chartDensity) chartDensity.destroy();
      chartHist = chartDensity = null;
      const boxCanvas = document.getElementById('boxCanvas');
      boxCanvas.getContext('2d').clearRect(0,0,boxCanvas.width,boxCanvas.height);
      setToast('—');
      btnCopy.disabled = true;
      lastReportText = '';
      lastHasData = false;
      return;
    }

    const sorted = [...nums].sort((a,b)=>a-b);
    const n = sorted.length;

    const min = sorted[0], max = sorted[n-1];
    const meanVal = mean(sorted);
    const medianVal = median(sorted);
    const sd = sampleStd(sorted);

    const { q1, q3 } = tukeyQuartiles(sorted);
    const iqr = q3 - q1;

    const lo = q1 - 1.5*iqr;
    const hi = q3 + 1.5*iqr;
    const outliers = sorted.filter(x => x < lo || x > hi);

    const skew = skewSummary(sorted);

    elParseInfo.textContent = `Parsed ${n} number(s). Ignored ${bad} invalid token(s).`;

    // Stats cards
    elStats.innerHTML = '';
    elStats.appendChild(statCard('n', `${n}`));
    elStats.appendChild(statCard('min', `${fmt(min)}`));
    elStats.appendChild(statCard('max', `${fmt(max)}`));
    elStats.appendChild(statCard('mean', `${fmt(meanVal)}`));
    elStats.appendChild(statCard('median', `${fmt(medianVal)}`));
    elStats.appendChild(statCard('sample SD', `${Number.isFinite(sd) ? fmt(sd) : '—'}`));
    elStats.appendChild(statCard('Q1 (25%)', `${fmt(q1)}`));
    elStats.appendChild(statCard('Q3 (75%)', `${fmt(q3)}`));
    elStats.appendChild(statCard('IQR', `${fmt(iqr)}`));
    elStats.appendChild(statCard('Tukey outliers', outliers.length ? `${outliers.length}` : '0'));

    // Interpretation
    const meanVsMed = (meanVal > medianVal)
      ? 'Mean > median, consistent with a right-tailed influence of larger values.'
      : (meanVal < medianVal)
        ? 'Mean < median, consistent with a left-tailed influence of smaller values.'
        : 'Mean ≈ median, consistent with approximate symmetry.';

    const outTxt = outliers.length
      ? `Outliers (Tukey fences): values < ${fmt(lo)} or > ${fmt(hi)} (count = ${outliers.length}).`
      : `No outliers detected by Tukey fences (< ${fmt(lo)} or > ${fmt(hi)}).`;

    elInterp.style.display = 'block';
    elInterp.innerHTML = `
      <div class="title">Interpretation</div>
      <div>• Distribution: <span class="mono">${skew.label}</span>.</div>
      <div>• ${meanVsMed}</div>
      <div>• ${outTxt}</div>
    `;

    // Histogram
    const fd = freedmanDiaconisBins(sorted);
    const bins = Math.min(60, Math.max(1, fd.bins));
    const hist = histogram(sorted, bins);

    const ctxH = document.getElementById('hist');
    if (chartHist) chartHist.destroy();
    chartHist = new Chart(ctxH, {
      type: 'bar',
      data: {
        labels: hist.labels,
        datasets: [{
          label: 'Count',
          data: hist.counts,
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        plugins: { legend: { display: false } },
        scales: {
          x: { ticks: { display: false } },
          y: { beginAtZero: true }
        }
      }
    });

    // Density
    const den = densityKDE(sorted);
    const ctxD = document.getElementById('density');
    if (chartDensity) chartDensity.destroy();
    chartDensity = new Chart(ctxD, {
      type: 'line',
      data: {
        labels: den.xs.map(x => fmt(x)),
        datasets: [{
          label: 'Density',
          data: den.ys,
          pointRadius: 0,
          borderWidth: 2,
          tension: 0.25
        }]
      },
      options: {
        responsive: true,
        plugins: { legend: { display: false } },
        scales: {
          x: { ticks: { display: false } },
          y: { beginAtZero: true }
        }
      }
    });

    // Consistent boxplot (manual draw)
    const boxCanvas = document.getElementById('boxCanvas');
    drawBoxplot(boxCanvas, { min, max, q1, q3, medianVal, lo, hi, outliers });

    // Report copy
    lastReportText = buildReportText({
      n, min, max, meanVal, medianVal, sd, q1, q3, iqr,
      lo, hi, outliersCount: outliers.length, skew
    });
    lastHasData = true;
    btnCopy.disabled = false;
    setToast('Ready.');
  }

  // -------------------- Clipboard --------------------
  async function copyToClipboard(text){
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (e) {
      try {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.setAttribute('readonly', '');
        ta.style.position = 'absolute';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        return ok;
      } catch {
        return false;
      }
    }
  }

  // -------------------- Events --------------------
  document.getElementById('analyze').addEventListener('click', () => {
    const { nums, bad } = parseNumbers(elData.value);
    render(nums, bad);
  });

  document.getElementById('example').addEventListener('click', () => {
    elData.value = "1, 2, 2, 3, 3, 4, 100\n5 6 7 8 9\n10";
    const { nums, bad } = parseNumbers(elData.value);
    render(nums, bad);
  });

  document.getElementById('clear').addEventListener('click', () => {
    elData.value = "";
    render([], 0);
  });

  btnCopy.addEventListener('click', async () => {
    if (!lastHasData || !lastReportText) return;
    const ok = await copyToClipboard(lastReportText);
    setToast(ok ? 'Copied.' : 'Copy failed (browser blocked clipboard).');
  });
</script>
</body>
</html>
